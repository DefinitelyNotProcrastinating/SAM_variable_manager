/**
 * Contains the Summary class, representing a single node in the Summary Tree (S-Tree).
 * This is a pure data structure.
 */

// Helper functions to avoid external dependencies for this standalone file.
const min = (arr) => Math.min(...arr);
const max = (arr) => Math.max(...arr);

export class Summary {
    /**
     * Creates an instance of a Summary node.
     * @param {number} index_begin - The starting index of the original chat history this summary covers.
     * @param {number} index_end - The ending index of the original chat history this summary covers.
     * @param {string} content - The summarized text content.
     * @param {number} level - The level of this summary in the hierarchy (e.g., 0 for base, 1 for a summary of summaries).
     */
    constructor(index_begin, index_end, content, level) {
        if (index_begin === undefined || index_end === undefined || level === undefined) {
            throw new Error("Summary node must have begin index, end index, and level.");
        }
        this.index_begin = index_begin;
        this.index_end = index_end;
        this.content = content;
        this.level = level;
    }

    /**
     * Creates a new, higher-level summary node by consolidating a list of lower-level summaries.
     * @param {Summary[]} srcs - An array of source Summary objects of the same level.
     * @param {string} new_content - The new summarized text content (assumed to be generated by an external LLM call).
     * @returns {Summary} A new Summary instance representing the next level up.
     */
    static upgrade(srcs, new_content) {
        if (!srcs || srcs.length === 0) {
            throw new Error("Source summaries array cannot be empty for an upgrade operation.");
        }

        const min_idx = min(srcs.map(low_lvl_summary => low_lvl_summary.index_begin));
        const max_idx = max(srcs.map(low_lvl_summary => low_lvl_summary.index_end));
        
        const lvl = srcs[0].level + 1;

        return new Summary(min_idx, max_idx, new_content, lvl);
    }
}